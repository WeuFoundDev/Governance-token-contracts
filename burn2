// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract MintingPool is Ownable {
    using SafeMath for uint256;

    uint256 public timechain = 50;
    uint256 public intToken = 1000000;
    uint256 public constant MAX_INTS = 1000000;

    // Function to burn and claim INT tokens based on the minting pool algorithm
    function burnAndClaim() external onlyOwner returns (uint256) {
        require(timechain > 0, "Timechain has ended");
        uint256 newSupply = 2000000; // Example: New inputs added to minting pool

        // Calculate the slashing percentage for the new supply
        uint256 slashingPercentage = calculateSlashingPercentage();

        // Calculate the slashing amount for each portion
        uint256 slashingAmountForExisting = intToken.mul(slashingPercentage).div(10**8); // Divide by 10**8 due to 6 decimal places
        uint256 slashingAmountForNew = newSupply.mul(slashingPercentage).div(10**8); // Divide by 10**8 due to 6 decimal places

        // Calculate the total slashed amount
        uint256 totalSlashedAmount = slashingAmountForExisting.add(slashingAmountForNew);

        // Apply slashing only if it reduces INT tokens to zero
        if (totalSlashedAmount >= intToken) {
            intToken = 0;
        } else {
            intToken = intToken.sub(totalSlashedAmount);
        }

        // Decrease the timechain period
        timechain--;

        return intToken;
    }

    // Function to calculate the slashing percentage based on the remaining timechain periods
    function calculateSlashingPercentage() internal view returns (uint256) {
        uint256 remainingTimechain = timechain.sub(1); // After 1 timechain, we will reduce intToken to zero
        uint256 slashingPercentage = MAX_INTS.mul(100 * 10**6).div(remainingTimechain).div(intToken); // Divide by 10**6 to get 6 decimal places
        return slashingPercentage;
    }
}
