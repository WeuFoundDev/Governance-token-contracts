// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

// This is the contract for our DAO.
contract DAO {
    using SafeMath for uint256;

    // Struct to represent a member.
    struct Member {
        bool exists; // Whether the member exists.
        uint256 shares; // Number of voting shares.
    }

    // Struct to store information about each proposal.
    struct Proposal {
        uint256 proposalIndex; // The proposal index.
        address proposer; // The address of the member who created the proposal.
        string description; // The proposal description.
        uint256 yesCount; // The number of Tokens that had "yes" votes.
        uint256 noCount; // The number of Tokens that had "no" votes.
        bool approved; // A flag to indicate whether the proposal has been approved or rejected.
        uint256 submitTime; // Submit Time for the voting period.
        bool processed; // A flag to indicate whether the proposal has been processed or not.
        mapping(address => bool) votedYes; // A specific user Voted Yes on this Proposal.
        mapping(address => bool) votedNo; // A specific user Voted No on this Proposal.
        uint256 membersParticipated; // Number of members who participated in this proposal's voting.
    }

    // Mapping to store the proposals, with the proposal index as the key.
    mapping(uint256 => Proposal) public proposals;
    mapping(address => Member) public members;
    uint256 public memberCount;

    // Minimum number of votes needed for a proposal to pass.
    uint256 public minimumQuorum;

    // Minimum percentage of yes votes needed for a proposal to pass.
    uint256 public minimumPercentage;

    // Number of seconds a proposal is active for.
    uint256 public votingPeriod;

    // Array to store the proposal indices, so that we can iterate over all the proposals.
    uint256[] public proposalIndices;

    address public owner;
    IERC20 public governanceToken;

    // Events
    event SubmitProposal(uint256 proposalId, address proposer, string description);
    event SubmitVote(uint256 proposalId, address voter, bool vote);
    event ProcessProposal(uint256 proposalId, bool result);
    event ProposalApproval(uint256 proposalId, bool approved);

    // Modifier to restrict access to only the contract owner.
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the contract owner can call this function.");
        _;
    }

    // Modifier to restrict access to only members.
    modifier onlyMember() {
        require(isMember(msg.sender), "Only members can call this function.");
        _;
    }

    // Modifier to check if a proposal exists before voting.
    modifier proposalExists(uint256 proposalId) {
        require(proposals[proposalId].proposer != address(0), "Proposal does not exist");
        _;
    }

    // Modifier to check if a proposal is within the voting time window before voting.
    modifier withinVotingPeriod(uint256 proposalId) {
        require(block.timestamp <= proposals[proposalId].submitTime.add(votingPeriod), "Voting period has expired");
        _;
    }

    // Modifier to check if a proposal has not been processed before voting.
    modifier notProcessed(uint256 proposalId) {
        require(!proposals[proposalId].processed, "Proposal has already been processed");
        _;
    }

    // Constructor
    constructor(address _governanceToken, uint256 _minimumQuorum, uint256 _votingPeriod, uint256 _minimumPercentage) {
        require(_minimumQuorum > 0, "Minimum quorum must be greater than zero.");
        require(_minimumPercentage > 0 && _minimumPercentage <= 100, "Minimum percentage must be between 1 and 100.");

        owner = msg.sender;
        governanceToken = IERC20(_governanceToken);
        minimumQuorum = _minimumQuorum;
        votingPeriod = _votingPeriod;
        minimumPercentage = _minimumPercentage;
        memberCount = 1;
        members[owner].exists = true;
    }

    // Function to propose a new member.
    function proposeMember(address newMember) public onlyOwner {
        require(!members[newMember].exists, "The member already exists.");
        members[newMember].exists = true;
        memberCount++;
    }

    // Function to remove a member.
    function removeMember(address existingMember) public onlyOwner {
        require(members[existingMember].exists, "The member doesn't exist.");
        require(existingMember != owner, "Cannot remove the contract owner.");
        members[existingMember].exists = false;
        memberCount--;
    }

    // Function to create a new proposal.
    function createProposal(string memory description) public onlyMember {
        uint256 proposalIndex = proposalIndices.length.add(1);

        Proposal storage proposal = proposals[proposalIndex];
        proposal.proposalIndex = proposalIndex;
        proposal.proposer = msg.sender;
        proposal.description = description;
        proposal.approved = false;
        proposal.submitTime = block.timestamp;

        proposalIndices.push(proposalIndex);

        emit SubmitProposal(proposalIndex, msg.sender, description);
    }

    // Function to vote on a proposal.
    function vote(uint256 proposalIndex, bool vote) public onlyMember proposalExists(proposalIndex) withinVotingPeriod(proposalIndex) notProcessed(proposalIndex) {
        Proposal storage proposal = proposals[proposalIndex];

        require(governanceToken.balanceOf(msg.sender) > 0, "Insufficient token balance to vote.");

        if (vote) {
            proposal.yesCount = proposal.yesCount.add(governanceToken.balanceOf(msg.sender));
            proposal.votedYes[msg.sender] = true;
        } else {
            proposal.noCount = proposal.noCount.add(governanceToken.balanceOf(msg.sender));
            proposal.votedNo[msg.sender] = true;
        }

        proposal.membersParticipated++;

        emit SubmitVote(proposalIndex, msg.sender, vote);
    }

    // Helper function to check if an address is a member of the DAO.
    function isMember(address addr) public view returns (bool) {
        return members[addr].exists;
    }

    // Function to process a proposal and determine the result.
    function processProposal(uint256 proposalId) public onlyOwner proposalExists(proposalId) notProcessed(proposalId) {
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp >= proposal.submitTime.add(votingPeriod), "Voting period has not expired yet");

        uint totalVotes = proposal.yesCount.add(proposal.noCount);
        uint minimumApproval = (memberCount.mul(minimumQuorum)).div(100);

        if (proposal.membersParticipated >= minimumApproval && proposal.yesCount.mul(100).div(totalVotes) > minimumPercentage) {
            proposal.approved = true;
        } else {
            proposal.approved = false;
        }

        proposal.processed = true;

        emit ProcessProposal(proposalId, proposal.approved);
        emit ProposalApproval(proposalId, proposal.approved);
    }
}
