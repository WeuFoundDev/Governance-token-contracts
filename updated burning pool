// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./Iint.sol";

contract TimechainProtocol is ReentrancyGuard{
    // Define the structure for the protocol's Burning pool
    struct BurningPool {
        uint256 totalInputs;
        uint256 timeChainsLeft;
        mapping(uint=>mapping(uint=>uint)) slashingPercentage; // slashingpercent[number of investment][Amount]=slashpercent
        mapping(uint => uint) amountStaked;
        uint256 noOfinvestments;
        address usdUsed;
        uint256 startingBlock;
        uint256 totalslashedAmount;
    }

    // Mapping to store the protocol's Burning pool data
    mapping(address => BurningPool) public BurningPools;

    // GLIPs vault to hold the slashed INT
    mapping(address => uint256) public glipsVaultAmount;

    address public stableCoin1;
    address public stableCoin2;
    address public stableCoin3;
    address public stableCoin4;
    address public glipsVault;
    Iint public intToken;
    address public owner;
    uint256 public timechainInterval; // Define the timechain interval here

    constructor(address _stableCoin1, address _stableCoin2, address _stableCoin3, address _stableCoin4, address _intToken) {
        stableCoin1 = _stableCoin1;
        stableCoin2 = _stableCoin2;
        stableCoin3 = _stableCoin3;
        stableCoin4 = _stableCoin4;
        intToken = Iint(_intToken);
        owner = msg.sender;
        timechainInterval = 1; // Set the timechain interval (you can modify this value as needed)
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can perform this action");
        _;
    }

    // Initialize the protocol's Burning pool with initial values
    function initializeBurningPool(address usdUsed, uint256 _totalamount) external nonReentrant {
        require(usdUsed != address(0), "The address cannot be equal to zero address");
        require(_totalamount != 0, "The given amount cannot be equal to zero ");
        require(BurningPools[msg.sender].totalInputs == 0, "Burning pool already initialized");
        require(BurningPools[msg.sender].noOfinvestments == 0, "The pool is already initialized");
        require(usdUsed == stableCoin1 || usdUsed == stableCoin2 || usdUsed == stableCoin3 || usdUsed == stableCoin4, "The token used should be any one of them");
        BurningPools[msg.sender].totalInputs = _totalamount;
        BurningPools[msg.sender].timeChainsLeft = 50;
        BurningPools[msg.sender].slashingPercentage[1][_totalamount] = 2;
        BurningPools[msg.sender].noOfinvestments = 1;
        BurningPools[msg.sender].amountStaked[1] = _totalamount;
        BurningPools[msg.sender].usdUsed = usdUsed;
        BurningPools[msg.sender].startingBlock = block.timestamp;
        // Transfer the usd to this account, before that he needs to give the approval for this contract
        IERC20(usdUsed).transferFrom(msg.sender, address(this), _totalamount);
    }

    // Function to add new inputs to the Burning pool
    function addInputsToBurningPool(uint256 _totalamount) external nonReentrant {
        require(_totalamount != 0, "The given amount cannot be equal to zero ");
        BurningPool storage pool = BurningPools[msg.sender];

        // Check if the timechain interval has passed
        require(block.timestamp >= pool.startingBlock + timechainInterval, "Cannot add inputs before the timechain interval is over");

        // Calculate the slashing percentage for the new supply of INT
        uint256 slashingPercentage = 100 / pool.timeChainsLeft;

        // Update the Burning pool data with the new inputs and slashing percentage
        pool.totalInputs += _totalamount;
        pool.noOfinvestments += 1;
        pool.amountStaked[pool.noOfinvestments] = _totalamount;
        pool.slashingPercentage[pool.noOfinvestments][_totalamount] = slashingPercentage;

        // Transfer the usd to this account, before that he needs to give the approval for this contract
        IERC20(pool.usdUsed).transferFrom(msg.sender, address(this), _totalamount);

        // Update the starting block of the current timechain
        pool.startingBlock = block.timestamp;
        // Decrease the number of timechains left
        pool.timeChainsLeft--;
    }

    // Function to slash the INT tokens based on the current timechain
    function slashTokens() external nonReentrant {
        BurningPool storage pool = BurningPools[msg.sender];
        require(pool.timeChainsLeft > 0, "The Timechains need to be greater than 0");

        // Check if the timechain interval has passed
        require(block.timestamp >= pool.startingBlock + timechainInterval, "Cannot slash before the timechain interval is over");

        uint completedTimeChains = (block.timestamp - pool.startingBlock) / timechainInterval;
        uint finalTimeChainsLeft = completedTimeChains - (50 - pool.timeChainsLeft);
        uint256 slashedAmount;

        for (uint i = 0; i <= pool.noOfinvestments; i++) {
            uint amountStaked = pool.amountStaked[i + 1];
            // Calculate the slashed amount for this period
            slashedAmount += (amountStaked * (pool.slashingPercentage[i + 1][amountStaked] * completedTimeChains)) / 100;
        }

        // Update the Burning pool's total inputs after slashing
        pool.totalslashedAmount += slashedAmount;
        // Add the slashed amount to the GLIPs vault
        glipsVaultAmount[msg.sender] += slashedAmount;
        // Decrease the number of timechains left
        pool.timeChainsLeft -= finalTimeChainsLeft;

        // Transfer the usd to the GLIPs vault
        IERC20(pool.usdUsed).transfer(glipsVault, slashedAmount);

        // Update the starting block of the current timechain
        pool.startingBlock = block.timestamp;
    }

    // Function to get the balance of INT available to spend at the start of the current timechain
    function getBalance() external view returns (uint256) {
        BurningPool storage pool = BurningPools[msg.sender];
        return pool.totalInputs - pool.totalslashedAmount;
    }

    function burnAndClaim(uint256 amount) external nonReentrant {
        require(amount != 0, "The amount cannot be equal to zero");
        require(intToken.balanceOf(msg.sender) >= amount, "Not sufficient amount in your wallet");
        require(IERC20(stableCoin1).balanceOf(address(this)) >= amount || IERC20(stableCoin2).balanceOf(address(this)) >= amount || IERC20(stableCoin3).balanceOf(address(this)) >= amount || IERC20(stableCoin4).balanceOf(address(this)) >= amount, "No sufficient amount in the pool");
        address currentStableCoin = findGreatest(stableCoin1, stableCoin2, stableCoin3, stableCoin4);
        intToken.burn(amount);
        IERC20(currentStableCoin).transfer(msg.sender, amount);
    }

    function findGreatest(address _stableCoin1, address _stableCoin2, address _stableCoin3, address _stableCoin4) public view returns (address) {
        // Using if-else statements
        address greatestCoin;

        if (IERC20(_stableCoin1).balanceOf(address(this)) >= IERC20(_stableCoin2).balanceOf(address(this)) && IERC20(_stableCoin1).balanceOf(address(this)) >= IERC20(_stableCoin3).balanceOf(address(this)) && IERC20(_stableCoin1).balanceOf(address(this)) >= IERC20(_stableCoin4).balanceOf(address(this))) {
            greatestCoin = _stableCoin1;
        } else if (IERC20(_stableCoin2).balanceOf(address(this)) >= IERC20(_stableCoin1).balanceOf(address(this)) && IERC20(_stableCoin2).balanceOf(address(this)) >= IERC20(_stableCoin3).balanceOf(address(this)) && IERC20(_stableCoin2).balanceOf(address(this)) >= IERC20(_stableCoin4).balanceOf(address(this))) {
            greatestCoin = _stableCoin2;
        } else if (IERC20(_stableCoin3).balanceOf(address(this)) >= IERC20(_stableCoin1).balanceOf(address(this)) && IERC20(_stableCoin3).balanceOf(address(this)) >= IERC20(_stableCoin2).balanceOf(address(this)) && IERC20(_stableCoin3).balanceOf(address(this)) >= IERC20(_stableCoin4).balanceOf(address(this))) {
            greatestCoin = _stableCoin3;
        } else {
            greatestCoin = _stableCoin4;
        }

        return greatestCoin;
    }
}
